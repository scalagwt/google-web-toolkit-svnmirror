<html>
<head><script>
var $wnd = parent;
var $doc = $wnd.document;
var $moduleName, $moduleBase
,$stats = $wnd.__gwtStatsEvent ? function(a) {return $wnd.__gwtStatsEvent(a);} : null;
if ($stats) {
  var moduleFuncName = location.search.substr(1);
  var moduleFunc = $wnd[moduleFuncName];
  var moduleName = moduleFunc ? moduleFunc.moduleName : "unknown";
  $stats({moduleName:moduleName,subSystem:'startup',evtGroup:'moduleStartup',millis:(new Date()).getTime(),type:'moduleEvalStart'});
}

var __eval = window.eval;
window.eval = function(s) {
  return __eval(s);
}

</script></head>
<body>
<embed id="pluginEmbed" type="application/x-gwt-hosted-mode" width="10" height="10">
</embed>
<object id="pluginObject" CLASSID="CLSID:1D6156B6-002B-49E7-B5CA-C138FB843B4E">
</object>
<font face='arial' size='-1'>This html file is for hosted mode support.</font>
<script><!--
var $hosted = "localhost:9997";

// wrapper to call JS methods, which we need both to be able to supply a
// different this for method lookup and to get the exception back
function __gwt_jsInvoke(thisObj, methodName) {
  try {
    var args = Array.prototype.slice.call(arguments, 2);
    return [0, window[methodName].apply(thisObj, args)];
  } catch (e) {
    return [1, e];
  }
}

var __gwt_javaInvokes = [];
function __gwt_makeJavaInvoke(argCount) {
  return __gwt_javaInvokes[argCount] || __gwt_doMakeJavaInvoke(argCount);
}

function __gwt_doMakeJavaInvoke(argCount) {
  // IE6 won't eval() anonymous functions except as r-values
  var argList = "";
  for (var i = 0; i < argCount; i++) {
    argList += ",p" + i;
  }
  var argListNoComma = argList.substring(1);

  return eval(
    "__gwt_javaInvokes[" + argCount + "] =\n" +
    "  function(thisObj, dispId" + argList + ") {\n" +
    "    var result = __static(dispId, thisObj" + argList + ");\n" +
    "    if (result[0]) {\n" +
    "      throw result[1];\n" +
    "    } else {\n" +
    "      return result[1];\n" +
    "    }\n" +
    "  }\n"
  ); 
}

/*
 * This is used to create tear-offs of Java methods.  Each function corresponds
 * to exactly one dispId, and also embeds the argument count.  We get the "this"
 * value from the context in which the function is being executed.
 * Function-object identity is preserved by caching in a sparse array.
 */
var __gwt_tearOffs = [];
var __gwt_tearOffGenerators = [];
function __gwt_makeTearOff(proxy, dispId, argCount) {
  return __gwt_tearOffs[dispId] || __gwt_doMakeTearOff(dispId, argCount);
}

function __gwt_doMakeTearOff(dispId, argCount) {
  return __gwt_tearOffs[dispId] = 
      (__gwt_tearOffGenerators[argCount] || __gwt_doMakeTearOffGenerator(argCount))(dispId);
}

function __gwt_doMakeTearOffGenerator(argCount) {
  // IE6 won't eval() anonymous functions except as r-values
  var argList = "";
  for (var i = 0; i < argCount; i++) {
    argList += ",p" + i;
  }
  var argListNoComma = argList.substring(1);

  return eval(
    "__gwt_tearOffGenerators[" + argCount + "] =\n" +
    "  function(dispId) {\n" +
    "    return function(" + argListNoComma + ") {\n" +
    "      var result = __static(dispId, this" + argList + ");\n" +
    "      if (result[0]) {\n" +
    "        throw result[1];\n" +
    "      } else {\n" +
    "        return result[1];\n" +
    "      }\n" +
    "    }\n" +
    "  }\n"
  ); 
}

function __gwt_makeResult(isException, result) {
  return [isException, result];
}

function gwtOnLoad(errFn, modName, modBase){
  $moduleName = modName;
  $moduleBase = modBase;

  /*
   * NOTE: this presently sucks and is the only formulation I can find that will
   * work across browsers.  On a Windows box where both plugins are registered,
   * FF will instantiate the (non-working) IE plugin.  But plugins have problems
   * that prevent making this easy.
   *
   * The IE plugin will throw an exception in FF if you try to resolve
   * "pluginObject.connect" as a value.  Thus the try/catch below.
   *
   * The FF plugin will actually do illegal crashy things in IE if you try to
   * resolve "pluginEmbed.connect" as a value.  Thus we have to try the IE
   * plugin first.
   *
   * Both plugins need some work to make them truly safe.  I have no idea what
   * will happen in Safari.
   */
  var plugins = [
    document.getElementById('pluginObject'),
    document.getElementById('pluginEmbed'),
  ];
  for (var i = 0; i < plugins.length; ++i) {
    try {
      var plugin = plugins[i];
      if (!plugin.connect($hosted, $moduleName, window)) {
        if (errFn) {
          errFn(modName);
        } else {
          alert("failed to connect to hosted mode server at " + $hosted);
        }
      }
      break;
    } catch (e) {
    }
  }
}

window.fireOnModuleLoadStart = function(className) {
  $stats && $stats({moduleName:$moduleName, subSystem:'startup', evtGroup:'moduleStartup', millis:(new Date()).getTime(), type:'onModuleLoadStart', className:className});
};

window.onunload = function() {
};

window.__gwt_module_id = 0;

var query = window.location.search;
$stats && $stats({moduleName:$moduleName,subSystem:'startup',evtGroup:'moduleStartup',millis:(new Date()).getTime(),type:'moduleEvalEnd'});
var idx = query.indexOf("gwt.hosted=");
if (idx >= 0) {
  var amp = query.indexOf("&", idx);
  if (amp >= 0) {
    $hosted = query.substring(idx + 11, amp);
  } else {
    $hosted = query.substring(idx + 11);
  }
}
idx = query.lastIndexOf("&");
query = query.substring(idx + 1);
if (query && $wnd[query]) setTimeout($wnd[query].onScriptLoad, 1);
--></script></body></html>
