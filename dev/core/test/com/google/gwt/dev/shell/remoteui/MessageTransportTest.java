package com.google.gwt.dev.shell.remoteui;

import com.google.gwt.dev.shell.remoteui.RemoteMessageProto.Message;
import com.google.gwt.dev.shell.remoteui.RemoteMessageProto.Message.Request;
import com.google.gwt.dev.shell.remoteui.RemoteMessageProto.Message.Response;

import junit.framework.TestCase;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public class MessageTransportTest extends TestCase {

  private static class MockNetwork {
    private final Socket clientSocket;
    private final Socket serverSocket;

    private final ServerSocket listenSocket;

    public MockNetwork(Socket clientSocket, Socket serverSocket,
        ServerSocket listenSocket) {
      this.clientSocket = clientSocket;
      this.serverSocket = serverSocket;
      this.listenSocket = listenSocket;
    }

    public Socket getClientSocket() {
      return clientSocket;
    }

    public Socket getServerSocket() {
      return serverSocket;
    }

    public void shutdown() {
      try {
        clientSocket.close();
      } catch (IOException e) {
        // Ignore
      }

      try {
        serverSocket.close();
      } catch (IOException e) {
        // Ignore
      }

      try {
        listenSocket.close();
      } catch (IOException e) {
        // Ignore
      }
    }
  }

  private static MockNetwork createMockNetwork() throws IOException,
      InterruptedException, ExecutionException {
    final ServerSocket listenSocket = new ServerSocket(0);
    ExecutorService executorService = Executors.newFixedThreadPool(1);
    Future<Socket> future = executorService.submit(new Callable<Socket>() {
      public Socket call() throws Exception {
        return listenSocket.accept();
      }
    });

    Socket clientSocket = new Socket("localhost", listenSocket.getLocalPort());
    Socket serverSocket = future.get();

    return new MockNetwork(clientSocket, serverSocket, listenSocket);
  }

  /**
   * Tests that a client request is successfully received by the
   * RequestProcessor, and the response generated by the RequestProcessor is
   * successfully received by the client.
   * 
   * @throws IOException
   * @throws ExecutionException
   * @throws InterruptedException
   */
  public void testClientRequestReceived() throws IOException,
      InterruptedException, ExecutionException {
    MockNetwork network = createMockNetwork();

    Message.Request.Builder clientRequestBuilder = Message.Request.newBuilder();
    clientRequestBuilder.setRequestId(25);
    clientRequestBuilder.setServiceType(Message.Request.ServiceType.DEV_MODE);
    final Message.Request clientRequest = clientRequestBuilder.build();

    Message.Response.Builder clientResponseBuilder = Message.Response.newBuilder();
    clientResponseBuilder.setRequestId(25);
    final Message.Response clientResponse = clientResponseBuilder.build();

    RequestProcessor requestProcessor = new RequestProcessor() {
      public Response execute(Request request) throws Exception {
        assertEquals(clientRequest, request);
        return clientResponse;
      }
    };

    MessageTransport messageTransport = new MessageTransport(
        network.getClientSocket().getInputStream(),
        network.getClientSocket().getOutputStream(), requestProcessor);

    Message.Builder clientRequestMsgBuilder = Message.newBuilder();
    clientRequestMsgBuilder.setMessageType(Message.MessageType.REQUEST);
    clientRequestMsgBuilder.setRequest(clientRequest);
    Message clientRequestMsg = clientRequestMsgBuilder.build();
    clientRequestMsg.writeDelimitedTo(network.getServerSocket().getOutputStream());

    Message receivedResponseMsg = Message.parseDelimitedFrom(network.getServerSocket().getInputStream());
    assertEquals(receivedResponseMsg.getResponse(), clientResponse);

    network.shutdown();
  }

  /**
   * Tests that a client request is successfully received by the
   * RequestProcessor, and the exception thrown by the RequestProcessor is
   * passed back in the form of an error response to the client.
   * 
   * @throws IOException
   * @throws ExecutionException
   * @throws InterruptedException
   */
  public void testClientRequestReceivedHandlerThrowsException() {
    // TODO: Implement once we add error message information to the protobufs
    // fail("Not yet implemented");
  }

  /**
   * Tests that sending an async request to a server when the sending stream is
   * closed will result in:
   * 
   * 1) A rejection of the request to the executor 2) An ExecutionException on a
   * call to future.get()
   * 
   * @throws ExecutionException
   * @throws InterruptedException
   * @throws IOException
   */
  public void testExecuteAsyncRequestWithClosedSendStream() throws IOException,
      InterruptedException, ExecutionException {
    MockNetwork network = createMockNetwork();

    RequestProcessor requestProcessor = new RequestProcessor() {
      public Response execute(Request request) throws Exception {
        fail("Should not reach here.");
        return null;
      }
    };

    MessageTransport messageTransport = new MessageTransport(
        network.getClientSocket().getInputStream(),
        network.getClientSocket().getOutputStream(), requestProcessor);

    Message.Request.Builder requestMessageBuilder = Message.Request.newBuilder();
    // FIXME: We are assuming what the request id is, based on knowledge of
    // MessageTransport's implementation. We need to provide a testing-only
    // method that allows us to specify (or peek at) the request id.
    requestMessageBuilder.setRequestId(0);
    requestMessageBuilder.setServiceType(Message.Request.ServiceType.DEV_MODE);
    Message.Request request = requestMessageBuilder.build();

    // Close the server's input stream; that will close the client's output
    // stream
    network.getServerSocket().getInputStream().close();

    Future<Response> responseFuture = null;
    responseFuture = messageTransport.executeRequestAsync(request);
    assertNotNull(responseFuture);

    try {
      responseFuture.get(2, TimeUnit.SECONDS);
      fail("Should have thrown an exception");
    } catch (TimeoutException te) {
      fail("Should not have timed out");
    } catch (ExecutionException e) {
      assertTrue(e.getCause() instanceof IllegalStateException);
    } catch (Exception e) {
      fail("Should not have thrown any other exception");
    }

    network.shutdown();
  }

  /**
   * Tests that an async request to a remote server is successfully sent, and
   * the server's response is successfully received.
   */
  public void testExecuteRequestAsync() throws InterruptedException,
      ExecutionException, IOException, TimeoutException {

    MockNetwork network = createMockNetwork();

    RequestProcessor requestProcessor = new RequestProcessor() {
      public Response execute(Request request) throws Exception {
        fail("Should not reach here.");
        return null;
      }
    };

    MessageTransport messageTransport = new MessageTransport(
        network.getClientSocket().getInputStream(),
        network.getClientSocket().getOutputStream(), requestProcessor);

    Message.Request.Builder requestMessageBuilder = Message.Request.newBuilder();
    // FIXME: We are assuming what the request id is, based on knowledge of
    // MessageTransport's implementation. We need to provide a testing-only
    // method that allows us to specify (or peek at) the request id.
    requestMessageBuilder.setRequestId(0);
    requestMessageBuilder.setServiceType(Message.Request.ServiceType.DEV_MODE);
    Message.Request request = requestMessageBuilder.build();

    Future<Response> responseFuture = messageTransport.executeRequestAsync(request);
    assertNotNull(responseFuture);

    Message receivedRequest = Message.parseDelimitedFrom(network.getServerSocket().getInputStream());
    assertEquals(receivedRequest.getRequest(), request);

    Message.Response.Builder responseBuilder = Message.Response.newBuilder();
    // FIXME: We are assuming what the request id is, based on knowledge of
    // MessageTransport's implementation. We need to provide a testing-only
    // method that allows us to specify (or peek at) the request id.
    responseBuilder.setRequestId(0);
    Message.Response response = responseBuilder.build();

    Message.Builder responseMsgBuilder = Message.newBuilder();
    responseMsgBuilder.setMessageType(Message.MessageType.RESPONSE);
    responseMsgBuilder.setResponse(response);
    Message responseMsg = responseMsgBuilder.build();

    responseMsg.writeDelimitedTo(network.getServerSocket().getOutputStream());
    assertEquals(responseFuture.get(2, TimeUnit.SECONDS), response);

    network.shutdown();
  }

  /**
   * Tests that a future for an async request to a remote server will hang if a
   * matching response is not received.
   * 
   * @throws ExecutionException
   * @throws InterruptedException
   * @throws IOException
   */
  public void testExecuteRequestAsyncReceiveUnmatchedResponse()
      throws IOException, InterruptedException, ExecutionException {
    MockNetwork network = createMockNetwork();

    RequestProcessor requestProcessor = new RequestProcessor() {
      public Response execute(Request request) throws Exception {
        fail("Should not reach here.");
        return null;
      }
    };

    MessageTransport messageTransport = new MessageTransport(
        network.getClientSocket().getInputStream(),
        network.getClientSocket().getOutputStream(), requestProcessor);

    Message.Request.Builder requestMessageBuilder = Message.Request.newBuilder();
    // FIXME: We are assuming what the request id is, based on knowledge of
    // MessageTransport's implementation. We need to provide a testing-only
    // method that allows us to specify (or peek at) the request id.
    requestMessageBuilder.setRequestId(0);
    requestMessageBuilder.setServiceType(Message.Request.ServiceType.DEV_MODE);
    Message.Request request = requestMessageBuilder.build();

    Future<Response> responseFuture = messageTransport.executeRequestAsync(request);
    assertNotNull(responseFuture);

    Message receivedRequest = Message.parseDelimitedFrom(network.getServerSocket().getInputStream());
    assertEquals(receivedRequest.getRequest(), request);

    Message.Response.Builder responseBuilder = Message.Response.newBuilder();
    // Unmatched request id
    responseBuilder.setRequestId(20);
    Message.Response response = responseBuilder.build();

    Message.Builder responseMsgBuilder = Message.newBuilder();
    responseMsgBuilder.setMessageType(Message.MessageType.RESPONSE);
    responseMsgBuilder.setResponse(response);
    Message responseMsg = responseMsgBuilder.build();

    responseMsg.writeDelimitedTo(network.getServerSocket().getOutputStream());

    try {
      responseFuture.get(2, TimeUnit.SECONDS);
      fail("Should have thrown an exception");
    } catch (TimeoutException te) {
      // This is where we should hit
    }

    network.shutdown();
  }

  /**
   * Tests that a future for an async request to a remote server will be
   * interrupted if the server closes the connection before the response is
   * received.
   */
  public void testExecuteRequestAsyncWithClosedReceiveStreamBeforeResponse()
      throws IOException, InterruptedException, ExecutionException,
      TimeoutException {
    MockNetwork network = createMockNetwork();

    RequestProcessor requestProcessor = new RequestProcessor() {
      public Response execute(Request request) throws Exception {
        fail("Should not reach here.");
        return null;
      }
    };

    MessageTransport messageTransport = new MessageTransport(
        network.getClientSocket().getInputStream(),
        network.getClientSocket().getOutputStream(), requestProcessor);

    Message.Request.Builder requestMessageBuilder = Message.Request.newBuilder();
    // FIXME: We are assuming what the request id is, based on knowledge of
    // MessageTransport's implementation. We need to provide a testing-only
    // method that allows us to specify (or peek at) the request id.
    requestMessageBuilder.setRequestId(0);
    requestMessageBuilder.setServiceType(Message.Request.ServiceType.DEV_MODE);
    Message.Request request = requestMessageBuilder.build();

    // assertNotNull(response);

    // This will close the client's input stream
    network.getServerSocket().getOutputStream().close();

    try {
      Future<Response> response = messageTransport.executeRequestAsync(request);
      response.get(2, TimeUnit.SECONDS);
      fail("Should have thrown an exception");
    } catch (TimeoutException te) {
      fail("Should not have timed out");
    } catch (ExecutionException e) {
      // This is where we should hit
      assertTrue(e.getCause() instanceof IllegalStateException);
    } catch (Exception e) {
      fail("Should not have thrown any other exception");
    }

    network.shutdown();
  }

  public void testMessageTransport() {
    // TODO: Implement tests for the constructor
    // fail("Not yet implemented");
  }
}
