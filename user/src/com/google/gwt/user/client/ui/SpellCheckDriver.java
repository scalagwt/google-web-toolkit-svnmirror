/*
 * Copyright 2006 Google Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package com.google.gwt.user.client.ui;

import com.google.gwt.user.client.Timer;
import com.google.gwt.user.client.rpc.IsSerializable;
import com.google.gwt.user.client.ui.richtext.Highlight;
import com.google.gwt.user.client.ui.richtext.HighlightCategory;
import com.google.gwt.user.client.ui.richtext.HighlightClickEvent;
import com.google.gwt.user.client.ui.richtext.HighlightClickHandler;
import com.google.gwt.user.client.ui.richtext.HighlightKeyboardEvent;
import com.google.gwt.user.client.ui.richtext.HighlightKeyboardHandler;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * Controls a UI component, most commonly a sub-component of
 * <code>RichTextEditor</code>, in order to enable spell checking. In MVC
 * terminology, the <code>SpellCheckDriver</code> encapsulates both the model
 * and controller for spell checking.
 * 
 */
public class SpellCheckDriver {

  /**
   * Allows the spell check driver and spell check data source to communicate.
   * Most implementations of <code>SpellCheckDriver.Broker</code> should be a
   * simple delegation to the user's server communication infrastructure, such
   * as an RPC Service.
   */
  public interface Broker {

    /**
     * Requests a new spell check. The broker is responsible for creating a
     * spell check <code>Response</code> object and passing it into
     * <code>request.handle(Response event)</code>.
     */
    public void request(Handler request);
  }

  /**
   * Handler for spell check request/response pairs. The handler object is used
   * by the spell check broker to generate and handle spell check responses.
   * <p>
   * Each handler is associated with a single Request object to simplify the
   * <code>SpellCheckDriver.Broker</code> machinery.
   */
  public static class Handler {

    private final SpellCheckDriver driver;
    private final Request request;

    private Handler(SpellCheckDriver driver, Request request) {
      this.driver = driver;
      this.request = request;
    }

    /**
     * Gets the <code>Request</code> object associated with this handler.
     * 
     * @return the request object
     */
    public Request getRequest() {
      return request;
    }

    /**
     * Handles the <code>Response</code> object generated by the spell check
     * broker.
     * 
     * @param response response
     */
    public void handle(Response response) {
      driver.startSpellCheck(response.getEntries());
    }
  }

  /**
   * Representing a single misspelled word and the set of suggestions associated
   * with that word.
   */
  public static class Misspelling implements IsSerializable {
    private String word;
    private String[] suggestions;

    /**
     * Gets the suggestions associated with the current misspelling.
     * 
     * @return the suggestions
     */
    public String[] getSuggestions() {
      return suggestions;
    }

    /**
     * Gets the misspelled word.
     * 
     * @return misspelled word.
     */
    public String getWord() {
      return word;
    }

    /**
     * Sets the suggestions associated with the current misspelling.
     * 
     * @param suggestions
     */
    public void setSuggestions(String[] suggestions) {
      this.suggestions = suggestions;
    }

    /**
     * Sets the misspelled word.
     * 
     * @param word the word
     */
    public void setWord(String word) {
      this.word = word;
    }

    public String toString() {
      return getWord() + Arrays.asList(getSuggestions()).toString();
    }
  }

  /**
   * Spell check Request. Created by the SpellCheckDriver.
   * <p>
   * All contained fields represent a snapshot of the spell check state when the
   * request was generated.
   * 
   */
  public static class Request implements IsSerializable {
    /**
     * Locale used for spell checking engine.
     */
    private String locale;

    /**
     * Text to extract misspelled words from.
     */
    private String text;

    /**
     * Gets the locale for spell checking.
     * 
     * @return spell check locale
     */
    public String getLocale() {
      return locale;
    }

    /**
     * Gets the text to extract misspelled words from.
     * 
     * @return returned text
     */
    public String getText() {
      return text;
    }

    /**
     * Sets the locale for spell checking. As there may be an arbitrary delay
     * between the request for a spell check and it's activation, we must cache
     * the spell check driver's locale.
     * 
     * @param locale spell check locale
     */
    public void setLocale(String locale) {
      this.locale = locale;
    }

    /**
     * Sets the text to extract misspelled words from. As there may be an
     * arbitrary delay between the request for a spell check and it's
     * activation, we must cache the spellcheckable's text.
     * 
     * @param text the text
     */
    public void setText(String text) {
      this.text = text;
    }
  }
  /**
   * Spell check Response. Created by the spell check broker. Comprises all
   * misspelled words represented in the spell check request's text.
   */
  public static class Response implements IsSerializable {
    private Misspelling[] entries;

    /**
     * Gets the misspelled words.
     */
    public Misspelling[] getEntries() {
      return entries;
    }

    /**
     * Sets the misspelled words.
     */
    public void setEntries(Misspelling[] entries) {
      this.entries = entries;
    }

    public String toString() {
      return Arrays.asList(getEntries()).toString();
    }
  }

  /**
   * UI component for spell checking. Must be able to supply misspelled text and
   * handle misspelled words.
   */
  public interface SpellCheckable {

    /**
     * Add highlights to show misspelled words. All highlights are assigned the
     * supplied type.
     * 
     * @param mispelledWords list of misspelled words
     * @param category highlight category
     * @return the iterator of created highlights
     */
    public Iterator addHighlights(List mispelledWords, HighlightCategory category);

    /**
     * Get the text to extract misspelled words from.
     * 
     * @return the text
     */
    public String getText();

    /**
     * Get the implementation of the "no suggestions" popup.
     * 
     * @return suggestion popup
     */
    SuggestionsPopup getNoSuggestionsPopup();

    /**
     * Sets the current spell check state.
     * 
     * @param state current spell check state
     */
    void setState(State state);
  }

  /**
   * Set of abstract UI states to control the <code>SpellCheckable</code>'s
   * spell check state.
   */
  public static class State {
    /**
     * Checking spelling ...
     */
    public static final State CHECKING = new State();
    /**
     * Ready to re-check ...
     */
    public static final State RECHECK = new State();
    /**
     * Ready to spell check ...
     */
    public static final State SPELLCHECK = new State();

    /**
     * Spell check completed with no misspellings...
     */
    public static final State NO_MISSPELLING = new State();
  }

  private static final int MILLISECONDS_DELAY = 500;

  private Broker broker;
  private List highlights;
  private String locale = "en";
  private SpellCheckable spellCheckable;

  /**
   * 
   * Constructor for <code>SpellCheckDriver</code>.
   * 
   * @param spellcheckable UI component used for spell checking
   */
  public SpellCheckDriver(SpellCheckable spellcheckable) {
    this.spellCheckable = spellcheckable;
  }

  /**
   * Finish currently active spell check.
   */
  public void finishSpellCheck() {
    clearHighlights();
    spellCheckable.setState(State.SPELLCHECK);
  }

  /**
   * Gets the spell check broker.
   * 
   * @return the broker
   */
  public Broker getBroker() {
    return broker;
  }

  /**
   * Gets the spell check locale.
   * 
   * @return spell check locale
   */
  public String getLocale() {
    return locale;
  }

  /**
   * Request a new spell check from the spell check broker.
   */
  public void requestSpellCheck() {
    spellCheckable.setState(State.CHECKING);
    clearHighlights();
    Request request = new Request();
    request.setText(spellCheckable.getText());
    request.setLocale(locale);
    final Handler spellCheckHandler = new Handler(this, request);

    if (broker == null) {
      throw new IllegalStateException(
          "Before Requesting a SpellCheck, you must provide a SpellCheckBroker.");
    }
    broker.request(spellCheckHandler);
  }

  /**
   * Sets the spell check broker.
   * 
   * @param broker the broker
   */
  public void setBroker(Broker broker) {
    this.broker = broker;
  }

  /**
   * Sets the spell check locale.
   * 
   * @param locale the locale
   */
  public void setLocale(String locale) {
    this.locale = locale;
  }

  /**
   * Starts a new spell check with the supplied set of misspellings.
   * 
   * @param misspellings supplied misspellings
   */
  public void startSpellCheck(Misspelling[] misspellings) {
    if (misspellings == null || misspellings.length == 0) {
      spellCheckable.setState(State.NO_MISSPELLING);
      Timer t = new Timer() {
        public void run() {
          spellCheckable.setState(State.SPELLCHECK);
        }
      };
      t.schedule(MILLISECONDS_DELAY);
    } else {
      process(misspellings);
      spellCheckable.setState(State.RECHECK);
    }
  }

  private void clearHighlights() {
    if (highlights != null) {
      for (int i = 0; i < highlights.size(); i++) {
        Highlight highlight = (Highlight) highlights.get(i);
        highlight.unhighlight();
      }
      highlights = null;
    }
  }

  private void process(Misspelling[] entries) {
    List mispelledWords = new ArrayList();
    final Map wordsToSuggestions = new HashMap();
    for (int i = 0; i < entries.length; i++) {
      mispelledWords.add(entries[i].getWord());
      wordsToSuggestions.put(entries[i].getWord(),
          Arrays.asList(entries[i].getSuggestions()));
    }
    HighlightCategory category = new HighlightCategory("misspelledWord");
    Iterator i = spellCheckable.addHighlights(mispelledWords, category);
    highlights = new ArrayList();
    while (i.hasNext()) {
      highlights.add(i.next());
    }

    abstract class HighlightClickAndKeyboardHandler implements
        HighlightClickHandler, HighlightKeyboardHandler {

      public void onKeyPress(HighlightKeyboardEvent e) {
      }

      public void onKeyUp(HighlightKeyboardEvent e) {
      }
    }

    HighlightClickAndKeyboardHandler spellCheck = new HighlightClickAndKeyboardHandler() {
      Highlight selected;
      final SuggestionsPopup popup = spellCheckable.getNoSuggestionsPopup();
      final SuggestionsPopup noSuggestions = new SuggestionsPopup();

      {

        popup.addChangeListener(new ChangeListener() {
          public void onChange(Widget sender) {
            selected.setText((String) popup.getSelectedValue());
            selected.unhighlight();
          }

        });
      }

      public void onClick(HighlightClickEvent event) {
        selected = event.getHighlight();
        select();
      }

      public void onKeyDown(HighlightKeyboardEvent e) {
        if (e.getControlKey() || e.getKeyCode() == '1') {
          System.err.println("got here");
        }
      }

      private void select() {
        Object key = selected.getHighlighted();
        List suggestions = (List) wordsToSuggestions.get(key);
        if (suggestions.size() > 0) {
          noSuggestions.hide();
          popup.setItems(suggestions);
          popup.showBelow(selected);
        } else {
          popup.hide();
          noSuggestions.showBelow(selected);
        }
      }
    };

    category.addClickHandler(spellCheck);
    category.addKeyboardHandler(spellCheck);
  }
}
